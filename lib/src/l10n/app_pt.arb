{
    "appSettings": "Configurações",
    "appSettingsTheme": "Tema",
    "appSettingsDefaultThemeSystem": "Tema padrão definido pelo sistema",
    "appSettingsDarkMode": "Modo escuro",
    "appSettingsLanguage": "Idioma",
    "appSettingsDefaultLanguageSystem": "Idioma padrão definido pelo sistema",
    "appSettingsLanguagePortuguese": "Português",
    "appSettingsLanguageEnglish": "Inglês",
    "appSettingsLanguageSpanish": "Espanhol",
    "appInfoTitle": "Informações",
    "appInfoLaunchError": "Não foi possível lançar",
    "appInfoFollowMe": "Siga-me",
    "appInfoAbout": "Sobre",
    "appInfoAboutDescription": "é uma ferramenta que auxilia com trechos de códigos do framework Flutter",
    "appNewsTitle": "Notícias",
    "appNewsError": "Algo deu errado, tente mais tarde",
    "appNewsNoNews": "Sem notícias",
    "appNewsDateFormat": "dd/MM/yyyy",
    "appNewsShowMore": "Mostrar mais",
    "appNewsShowLess": "Mostrar menos",
    "tabBarTitleExample": "Exemplo",
    "tabBarTitleCode": "Código",
    "utilCopyCodeMessage": "Código copiado",
    "utilToastClose": "Fechar",
    "utilAlertNoInformation": "Nenhuma informação disponível",
    "filterSearchLabel": "Pesquisar {filter}",
    "filterSearchHint": "{filter}",
    "filterSearchNoResults": "Nenhum resultado",
    "filterBadgeNew": "Novo",
    "filterBadgeUpdated": "Atualizado",
    "menuDartBasicDart": "Dart Básico",
    "menuDartBasicComments": "Comentários",
    "menuDartBasicVariables": "Variáveis",
    "menuDartBasicNomenclatures": "Nomenclaturas",
    "menuDartBasicTypes": "Tipagens",
    "menuDartBasicMathOperations": "Operações Matemáticas",
    "menuDartBasicConcatenationStrings": "Concatenação de Strings",
    "menuDartBasicNullSafety": "Null Safety",
    "menuDartBasicFluxControl": "Controle de Fluxo",
    "menuDartBasicFunctionsParameters": "Funções e Parâmetros",
    "menuDartAdvancedDart": "Dart Avançado",
    "menuDartAdvancedFilterClass": "Classe",
    "menuDartAdvancedFilterPrivatePublic": "Privado ou Público",
    "menuDartAdvancedFilterGetterSetter": "Getter e Setter",
    "menuDartAdvancedFilterConstructor": "Construtor",
    "menuDartAdvancedFilterExtends": "Estender",
    "menuDartAdvancedFilterAbstract": "Abstrato",
    "menuDartAdvancedFilterImplements": "Implementos",
    "menuDartAdvancedFilterPolymorphism": "Polimorfismo",
    "menuDartAdvancedList": "Lista",
    "menuDartAdvancedMap": "Mapeamento",
    "menuDartAdvancedOperatorSpread": "Operador Spread",
    "menuDartAdvancedCascadeOperator": "Operador Cascata",
    "menuDartAdvancedPubSpec": "PubSpec",
    "menuDartAdvancedTypedef": "Typedef",
    "menuDartAdvancedSplit": "Split",
    "menuDartAdvancedJoin": "Join",
    "menuDartAdvancedConvert": "Converter",
    "menuWidgetCreate": "Widgets de Criação",
    "menuWidgetCreateStateless": "Widget Sem estado",
    "menuWidgetCreateStateful": "Widget Com estado",
    "menuWidgetBasic": "Widgets Básico",
    "menuWidgetAdvanced": "Widgets Avançado",
    "menuWidgetApps": "Apps",
    "menuWidgetBasicSafeArea": "SafeArea",
    "menuWidgetBasicCircularProgressIndicator": "CircularProgressIndicator",
    "menuWidgetBasicContainer": "Container",
    "menuWidgetBasicText": "Texto",
    "menuWidgetBasicTextOverflow": "Texto com Overflow",
    "menuWidgetBasicTextStyle": "Texto com estilização",
    "menuWidgetBasicTextDefaultStyle": "Texto com estilo padrão",
    "menuWidgetBasicRichText": "RichText",
    "menuWidgetBasicColumn": "Coluna",
    "menuWidgetBasicRow": "Linhas",
    "menuWidgetBasicDivider": "Divisor",
    "menuWidgetBasicVerticalDivider": "Divisor Vertical",
    "menuWidgetBasicTextButton": "TextButton",
    "menuWidgetBasicElevatedButton": "ElevatedButton",
    "menuWidgetBasicElevatedButtonIcon": "ElevatedButton com Ícone",
    "menuWidgetBasicOutlinedButton": "OutlinedButton",
    "menuWidgetBasicIcon": "Ícone",
    "menuWidgetBasicIconBackground": "Ícone com fundo",
    "menuWidgetBasicImage": "Imagem",
    "menuWidgetBasicBottomSheet": "BottomSheet",
    "menuWidgetBasicMediaQuery": "MediaQuery",
    "menuWidgetBasicGestureDetector": "GestureDetector",
    "menuWidgetBasicInkWell": "InkWell",
    "menuWidgetBasicCard": "Card",
    "menuWidgetBasicFutureBuilder": "FutureBuilder",
    "menuWidgetBasicStack": "Pilha",
    "menuWidgetBasicPageView": "PageView",
    "menuWidgetBasicTable": "Tabela",
    "menuWidgetBasicSnackBar": "SnackBar",
    "menuWidgetBasicDialog": "Dialog",
    "menuWidgetBasicListView": "ListView",
    "menuWidgetBasicRotatedBox": "Caixa Girada",
    "menuWidgetBasicClipRect": "ClipRect",
    "menuWidgetBasicClipRRect": "ClipRRect",
    "menuWidgetBasicClipOval": "ClipOval",
    "menuWidgetBasicFlexible": "Flexible",
    "menuWidgetBasicExpanded": "Expanded",
    "menuWidgetBasicCircleAvatar": "CircleAvatar",
    "menuWidgetBasicFittedBox": "FittedBox",
    "menuWidgetBasicVisibility": "Visibilidade",
    "menuWidgetBasicBoxDecoration": "BoxDecoration",
    "menuWidgetBasicSelectableText": "SelectableText",
    "menuWidgetBasicInteractiveViewer": "InteractiveViewer",
    "menuWidgetBasicAspectRatio": "AspectRatio",
    "menuWidgetBasicPlaceholder": "Placeholder",
    "menuWidgetBasicSpacer": "Spacer",
    "menuWidgetBasicListWheelScrollView": "ListWheelScrollView",
    "menuWidgetBasicOpacity": "Opacidade",
    "menuWidgetBasicConstrainedBox": "ConstrainedBox",
    "menuWidgetBasicAlign": "Alinhar",
    "menuWidgetBasicPadding": "Padding",
    "menuWidgetBasicAbsorbPointer": "AbsorbPointer",
    "menuWidgetBasicIgnorePointer": "IgnorePointer",
    "menuWidgetBasicTooltip": "Tooltip",
    "menuWidgetBasicColors": "Cores",
    "menuWidgetBasicFlutterLogo": "FlutterLogo",
    "menuWidgetBasicSizedBox": "SizedBox",
    "menuWidgetBasicFloatingActionButton": "FloatingActionButton",
    "menuWidgetBasicCheckbox": "Checkbox",
    "menuWidgetBasicEndDrawer": "EndDrawer",
    "menuWidgetBasicContainerTransform": "ContainerTransform",
    "menuWidgetBasicTransform": "Transformar",
    "menuWidgetBasicBanner": "Banner",
    "menuWidgetBasicBorderRadius": "BorderRadius",
    "menuWidgetBasicSingleChildScrollView": "SingleChildScrollView",
    "menuWidgetBasicBoxShadow": "BoxShadow",
    "menuWidgetBasicShaderMask": "ShaderMask",
    "menuWidgetBasicColorFiltered": "ColorFiltered",
    "menuWidgetBasicDataTable": "DataTable",
    "menuWidgetBasicImageFiltered": "ImageFiltered",
    "menuWidgetBasicPositioned": "Positioned",
    "menuWidgetBasicLinearProgressIndicator": "LinearProgressIndicator",
    "menuWidgetBasicRawString": "RawString",
    "menuWidgetBasicLimitedBox": "LimitedBox",
    "menuWidgetBasicCheckboxListTile": "CheckboxListTile",
    "menuWidgetBasicSwitchListTile": "SwitchListTile",
    "menuWidgetBasicExpansionPanelList": "ExpansionPanelList",
    "menuWidgetBasicFractionallySizedBox": "FractionallySizedBox",
    "menuWidgetBasicScrollbar": "Scrollbar",
    "menuWidgetBasicOverflowBox": "OverflowBox",
    "menuWidgetBasicRadioListTile": "RadioListTile",
    "menuWidgetBasicTextField": "TextField",
    "menuWidgetBasicHapticFeedback": "HapticFeedback",
    "menuWidgetBasicDataTableWithSort": "DataTable com classificação",
    "menuWidgetBasicExpansionTile": "ExpansionTile",
    "menuWidgetBasicLinearGradient": "LinearGradient",
    "menuWidgetBasicBaseline": "Baseline",
    "menuWidgetBasicActionChip": "ActionChip",
    "menuWidgetBasicBackdropFilter": "BackdropFilter",
    "menuWidgetBasicExpandIcon": "ExpandIcon",
    "menuWidgetBasicShapeDecoration": "ShapeDecoration",
    "menuWidgetBasicImageIcon": "ImageIcon",
    "menuWidgetBasicChoiceChip": "ChoiceChip",
    "menuWidgetBasicDecorationImage": "DecorationImage",
    "menuWidgetBasicUnconstrainedBox": "UnconstrainedBox",
    "menuWidgetBasicIntrinsicWidth": "IntrinsicWidth",
    "menuWidgetBasicBorderSide": "BorderSide",
    "menuWidgetBasicSwitch": "Switch",
    "menuWidgetBasicBoxFit": "BoxFit",
    "menuWidgetBasicAppBar": "AppBar",
    "menuWidgetBasicMaterialBanner": "MaterialBanner",
    "menuWidgetAdvancedRefreshIndicator": "RefreshIndicator",
    "menuWidgetAdvancedDraggable": "Drag and Drop",
    "menuWidgetAdvancedGlobalKey": "GlobalKey",
    "menuWidgetAdvancedDrawer": "Drawer",
    "menuWidgetAdvancedDropdown": "Dropdown",
    "menuWidgetAdvancedDismissible": "Dismissible",
    "menuWidgetAdvancedGridView": "GridView",
    "menuWidgetAdvancedSliverAppBar": "SliverAppBar",
    "menuWidgetAdvancedSliverGrid": "SliverGrid",
    "menuWidgetAdvancedNavigator": "Navegador",
    "menuWidgetAdvancedNavigatorWithArguments": "Navegador com Argumentos",
    "menuWidgetAdvancedSendDataToScreen": "Enviar Dados para a Tela",
    "menuWidgetAdvancedPopupMenuButton": "PopupMenuButton",
    "menuWidgetAdvancedTabs": "Abas",
    "menuWidgetAdvancedClipPath": "ClipPath",
    "menuWidgetAdvancedSlider": "Slider",
    "menuWidgetAdvancedListViewWithSearch": "ListViewWithSearch",
    "menuWidgetAdvancedChip": "Chip",
    "menuWidgetAdvancedImageLoadingBuilder": "ImageLoadingBuilder",
    "menuWidgetAdvancedMouseRegion": "MouseRegion",
    "menuWidgetAdvancedLayoutBuilder": "LayoutBuilder",
    "menuWidgetAdvancedBottomNavigationBar": "BottomNavigationBar",
    "menuWidgetAdvancedExpansionPanel": "ExpansionPanel",
    "menuWidgetAdvancedPaint": "Paint",
    "menuWidgetAdvancedLoadJson": "LoadJson",
    "menuWidgetAdvancedClipboard": "Clipboard",
    "menuWidgetAdvancedPageRouteBuilder": "PageRouteBuilder",
    "menuWidgetAdvancedLoadTxt": "LoadTxt",
    "menuWidgetAdvancedIndexedStack": "IndexedStack",
    "menuWidgetAdvancedScrollController": "ScrollController",
    "menuWidgetAdvancedPageTransition": "PageTransition",
    "menuWidgetAdvancedSplashScreen": "SplashScreen",
    "menuWidgetAdvancedPushNamed": "PushNamed",
    "menuWidgetAdvancedOnGenerateRoute": "OnGenerateRoute",
    "menuWidgetAdvancedWillPopScope": "WillPopScope",
    "menuWidgetAdvancedStepper": "Stepper",
    "menuWidgetAdvancedToggleButtons": "ToggleButtons",
    "menuWidgetAdvancedDatePicker": "DatePicker",
    "menuWidgetAdvancedScrollToBottomOrTop": "ScrollToBottomOrTop",
    "menuWidgetAdvancedAutocomplete": "Autocomplete",
    "menuWidgetAdvancedHideKeyboard": "Esconder teclado",
    "menuWidgetAdvancedNavigationRail": "NavigationRail",
    "menuWidgetAdvancedFlow": "Flow",
    "menuWidgetAdvancedCustomSingleChildLayout": "CustomSingleChildLayout",
    "menuWidgetAdvancedFilterChip": "FilterChip",
    "menuWidgetAdvancedInputChip": "InputChip",
    "menuWidgetAdvancedListViewBuilder": "ListViewBuilder",
    "menuWidgetAdvancedOverlayEntry": "OverlayEntry",
    "menuWidgetAdvancedLongPressDraggable": "LongPressDraggable",
    "menuWidgetAppStopwatch": "Cronômetro",
    "menuWidgetAppCountdown": "Contagem regressiva",
    "menuWidgetAppQuiz": "Quiz",
    "menuWidgetAppCalculator": "Calculator",
    "menuAnimation": "Animações",
    "menuAnimationAnimationIcon": "Ícone de Animação",
    "menuAnimationAnimatedContainer": "AnimatedContainer",
    "menuAnimationAnimatedCrossFade": "AnimatedCrossFade",
    "menuAnimationAnimatedOpacity": "AnimatedOpacity",
    "menuAnimationAnimatedDefaultTextStyle": "AnimatedDefaultTextStyle",
    "menuAnimationCustomPaint": "CustomPaint",
    "menuAnimationRotatingCircle": "RotatingCircle",
    "menuAnimationMatrix": "Matrix",
    "menuAnimationDraggableScrollableSheet": "DraggableScrollableSheet",
    "menuAnimationAnimatedImage": "Imagem Animada",
    "menuAnimationHero": "Hero",
    "menuAnimationFadeInImage": "FadeInImage",
    "menuAnimationFadeTransition": "FadeTransition",
    "menuAnimationAnimatedSwitcher": "AnimatedSwitcher",
    "menuAnimationAnimatedList": "AnimatedList",
    "menuAnimationSlideTransition": "SlideTransition",
    "menuAnimationAnimatedSize": "AnimatedSize",
    "menuAnimationAnimatedPadding": "AnimatedPadding",
    "menuAnimationAnimatedModalBarrier": "AnimatedModalBarrier",
    "menuAnimationRotationTransition": "RotationTransition",
    "menuMain": "Main",
    "menuMainDeviceOrientation": "DeviceOrientation",
    "menuMainSystemUIOverlayStyle": "SystemUIOverlayStyle",
    "tipRotatedBox": "O widget RotatedBox é usado para girar seu filho por um número inteiro de quartos de volta. Ele é usado para orientar seus widgets filhos na orientação horizontal ou vertical. Além disso, é muito leve e pode ser usado para projetar várias interfaces do usuário, pois dá flexibilidade ao usuário em relação ao design do aplicativo.",
    "tipSafeArea": "SafeArea é um widget importante e útil no Flutter que torna a IU dinâmica e adaptável a uma ampla variedade de dispositivos. Ao projetar o layout dos widgets, consideramos diferentes tipos de dispositivos e suas restrições pré-ocupadas de tela, como barra de status, entalhes, barra de navegação, etc. Mas novos dispositivos estão sendo lançados com designs diferentes e em certos cenários, seu aplicativo pode se sobrepor qualquer uma dessas restrições pré-ocupadas. Portanto, para tornar nossa IU adaptável e livre de erros, usamos o widget SafeArea. Em palavras simples, SafeArea é basicamente um widget de preenchimento, que adiciona qualquer preenchimento necessário ao seu aplicativo, com base no dispositivo em que está sendo executado. Se os widgets de seu aplicativo estão sobrepondo qualquer um dos recursos do sistema, como entalhes, barra de status, orifícios de câmera ou qualquer outro recurso, o SafeArea adicionaria preenchimento ao redor do aplicativo, conforme necessário. Internamente, SafeArea usa MediaQuery para verificar as dimensões da tela de exibição e inclui preenchimento extra, se necessário.",
    "tipContainer": "A classe Container em flutter é um widget de conveniência que combina pintura, posicionamento e dimensionamento comuns de widgets. Uma classe Container pode ser usada para armazenar um ou mais widgets e posicioná-los na tela de acordo com nossa conveniência. Basicamente, um contêiner é como uma caixa para armazenar o conteúdo. Um elemento de contêiner básico que armazena um widget tem uma margem, que separa o contêiner presente de outros conteúdos. O contêiner total pode receber uma borda de diferentes formas, por exemplo, retângulos arredondados, etc. Um contêiner envolve seu filho com preenchimento e, em seguida, aplica restrições adicionais à extensão preenchida (incorporando a largura e a altura como restrições, se qualquer uma delas não for nulo).",
    "tipText": "O widget de texto exibe uma string de texto com um único estilo. A sequência pode quebrar em várias linhas ou pode ser exibida na mesma linha, dependendo das restrições de layout.",
    "tipRichText": "O widget RichText é usado para exibir texto que usa vários estilos diferentes. O texto exibido é descrito usando uma árvore de objetos TextSpan, cada um dos quais com seu próprio estilo associado que é usado para aquela subárvore. Dependendo das restrições de layout, o texto pode quebrar em várias linhas ou pode ser exibido na mesma linha.",
    "tipColumn": "Linha e coluna são os dois widgets mais importantes e poderosos do Flutter. Esses widgets permitem alinhar os filhos horizontalmente e verticalmente de acordo com o requisito. Como sabemos que quando projetamos qualquer IU (Interface do Usuário) com agitação, precisamos organizar seu conteúdo na forma de Linha e Coluna, de forma que esses widgets de Linha e Coluna sejam necessários ao projetar a IU. Ele cria uma matriz vertical de filhos. Propriedades de alinhamento: Neste também temos mainAxisAlignment e crossAxisAlignment. Na coluna, os filhos são alinhados de cima para baixo. O eixo principal é vertical e o eixo cruzado é horizontal. MainAxisAlignment alinha seus filhos verticalmente e CrossAxisAlignment alinha horizontalmente nessa coluna.",
    "tipRow": "Linha e coluna são os dois widgets mais importantes e poderosos do Flutter. Esses widgets permitem alinhar os filhos horizontalmente e verticalmente de acordo com o requisito. Como sabemos que quando projetamos qualquer IU (Interface do Usuário) com agitação, precisamos organizar seu conteúdo na forma de Linha e Coluna, de forma que esses widgets de Linha e Coluna sejam necessários ao projetar a IU. Ele cria uma matriz horizontal de filhos. Propriedades de alinhamento: Podemos alinhar o conteúdo de acordo com nossa escolha usando mainAxisAlignment e crossAxisAlignment. O eixo principal de Row é horizontal e o eixo transversal para o eixo principal de Row é vertical. Podemos alinhar os filhos horizontalmente usando MainAxisAlignment e verticalmente usando CrossAxisAlignment nessa linha.",
    "tipDivider": "Uma linha horizontal fina, com acolchoamento de cada lado. Na linguagem do material design, isso representa um divisor. Os divisores podem ser usados em listas, gavetas e em outros lugares para separar o conteúdo.",
    "tipVerticalDivider": "Uma linha vertical fina, com acolchoamento de cada lado. Na linguagem do material design, isso representa um divisor. Divisores verticais podem ser usados em listas de rolagem horizontal, como ListView com ListView.scrollDirection definido como Axis.horizontal. A largura total da caixa é controlada pela largura. O preenchimento apropriado é calculado automaticamente a partir da largura.",
    "tipButton": "Use botões de texto em barras de ferramentas, em diálogos ou em linha com outro conteúdo, mas desloque-se desse conteúdo com preenchimento para que a presença do botão seja óbvia. Os botões de texto não têm bordas visíveis e, portanto, devem depender de sua posição em relação a outro conteúdo para contexto. Em caixas de diálogo e cartões, eles devem ser agrupados em um dos cantos inferiores. Evite usar botões de texto onde eles se misturariam a outro conteúdo, por exemplo, no meio de listas.",
    "tipIcon": "A classe de ícone no Flutter é usada para mostrar ícones específicos em nosso aplicativo. Em vez de criar uma imagem para nosso ícone, podemos simplesmente usar a classe Icon para inserir um ícone em nosso aplicativo. Para usar esta classe, você deve garantir que definiu usa-material-design: true no arquivo pubspec.yml de seu objeto.",
    "tipImage": "Os aplicativos Flutter podem incluir código e ativos (às vezes chamados de recursos). Um ativo é um arquivo que é empacotado e implantado com seu aplicativo e pode ser acessado em tempo de execução. Os tipos comuns de ativos incluem dados estáticos (por exemplo, arquivos JSON), arquivos de configuração, ícones e imagens (JPEG, WebP, GIF, WebP / GIF animado, PNG, BMP e WBMP).",
    "tipBottomSheet": "Folha inferior modal é uma alternativa a um menu ou caixa de diálogo e evita que o usuário interaja com o resto do aplicativo. Ele aparecerá na interface do usuário para que não haja necessidade de navegar para uma página diferente. Ele pode ser usado para realizar uma pequena tarefa que não requeira a construção de uma nova tela.",
    "tipMediaQuery": "Durante o processo de desenvolvimento de um aplicativo para telefones e tablets, é uma prática padrão ter diferentes layouts de IU para diferentes tamanhos de tela para uma melhor experiência do usuário. Se o usuário tem uma preferência definida para diferentes tamanhos de fonte ou deseja reduzir as animações. É aqui que o MediaQuery entra em ação, você pode obter informações sobre o tamanho do dispositivo atual, bem como as preferências do usuário, e projetar seu layout de acordo. MediaQuery fornece uma visão de nível superior do tamanho da tela do aplicativo atual e também pode fornecer informações mais detalhadas sobre o dispositivo e suas preferências de layout. Na prática, MediaQuery está sempre lá. Ele pode ser acessado simplesmente chamando MediaQuery.of no método de construção. A partir daí, você pode pesquisar todos os tipos de informações interessantes sobre o dispositivo em que está executando, como o tamanho da tela, e construir seu layout de acordo. MediaQuery também pode ser usado para verificar a orientação do dispositivo atual ou pode ser usado para verificar se o usuário modificou o tamanho da fonte padrão. Ele também pode ser usado para determinar se partes da tela estão obscurecidas por uma IU do sistema, semelhante a um widget de área segura.",
    "tipDraggable": "Quando um widget arrastável reconhece o início de um gesto de arrastar, ele exibe um widget de feedback que rastreia o dedo do usuário pela tela. Se o usuário levantar o dedo enquanto estiver em cima de um DragTarget, esse alvo terá a oportunidade de aceitar os dados carregados pelo draggable. Em dispositivos multitoque, vários arrastamentos podem ocorrer simultaneamente porque pode haver vários ponteiros em contato com o dispositivo ao mesmo tempo. Para limitar o número de arrastamentos simultâneos, use a propriedade maxSimultaneousDrags. O padrão é permitir um número ilimitado de arrastos simultâneos.",
    "tipGlobalKey": "Uma chave única em todo o aplicativo. As chaves globais identificam os elementos de maneira exclusiva. As chaves globais fornecem acesso a outros objetos associados a esses elementos, como BuildContext. Para StatefulWidgets, as chaves globais também fornecem acesso a State. Os widgets que possuem chaves globais corrigem suas subárvores quando são movidos de um local da árvore para outro local na árvore. Para reparar sua subárvore, um widget deve chegar em seu novo local na árvore no mesmo quadro de animação em que foi removido de seu antigo local na árvore. Reparar um elemento usando uma chave global é relativamente caro, pois esta operação irá disparar uma chamada para State.deactivate no estado associado e todos os seus descendentes; em seguida, force a reconstrução de todos os widgets que dependem de um InheritedWidget.",
    "tipGestureDetector": "Um widget que detecta gestos. Tenta reconhecer gestos que correspondem a seus retornos de chamada não nulos. Se este widget tiver um filho, ele atribuirá a esse filho seu comportamento de dimensionamento. Se não tiver um filho, ele cresce para se adequar ao pai. Por padrão, um GestureDetector com uma criança invisível ignora os toques; este comportamento pode ser controlado com comportamento. GestureDetector também escuta eventos de acessibilidade e os mapeia para os callbacks. Para ignorar eventos de acessibilidade, defina excludeFromSemantics como true.",
    "tipInkWell": "InkWell é o widget de material vibrante. Ele responde à ação de toque executada pelo usuário. O Inkwell responderá quando o usuário clicar no botão. Existem tantos gestos como toque duplo, toque longo, toque para baixo, etc. Abaixo estão as tantas propriedades deste widget. Podemos definir o raio do widget do tinteiro usando radius e também border-radius usando borderRadius. Podemos dar a cor inicial usando splashColor e fazer muitas coisas.",
    "tipCard": "O cartão é um widget integrado em vibração que deriva seu design da Biblioteca de design de materiais do Google. A funcionalidade desse widget na tela é um espaço sem graça ou painel com cantos arredondados e uma ligeira elevação na parte inferior. Ele vem com muitas propriedades como cor, forma, cor de sombra, etc, o que permite aos desenvolvedores personalizá-lo da maneira que quiserem.",
    "tipDrawer": "O widget Drawer é usado como um sub-roteador adicional que consiste em vários links para outras rotas (ou seja, páginas) no mesmo aplicativo. Possui um movimento horizontal a partir da borda do andaime que navega no link para diferentes rotas no aplicativo flutter. Todos os filhos de um widget Drawer estão geralmente em ListView e, inicialmente, apenas o DrawerHeader está presente na IU que, quando tocado, se estende horizontalmente.",
    "tipTabs": "As guias são exatamente o que você pensa. É parte da IU que conduz o usuário por diferentes rotas (ou seja, páginas) quando clicado. O uso de guias em aplicativos é uma prática padrão. Flutter fornece uma maneira simples de criar layouts de guia usando a biblioteca de materiais.",
    "tipDropdown": "Um botão de design de material para selecionar em uma lista de itens. Um botão suspenso permite que o usuário selecione a partir de uma série de itens. O botão mostra o item atualmente selecionado, bem como uma seta que abre um menu para selecionar outro item.",
    "tipFutureBuilder": "No Flutter, o widget FutureBuilder é usado para criar widgets com base no instantâneo mais recente de interação com um futuro. É necessário que o Future seja obtido mais cedo por meio de uma mudança de estado ou de uma mudança nas dependências. FutureBuilder é um widget que o ajudará a executar algumas funções assíncronas e, com base no resultado dessa função, sua IU será atualizada. FutureBuilder é Stateful por natureza, ou seja, mantém seu próprio estado como fazemos em StatefulWidgets.",
    "tipStack": "Stack widget é um widget embutido no flutter SDK que nos permite criar uma camada de widgets, colocando-os em cima uns dos outros. Muitas vezes, um layout simples de linha e coluna não é suficiente, precisamos de uma maneira de sobrepor um widget sobre o outro, por exemplo, podemos querer mostrar algum texto sobre uma imagem, então, para resolver tal situação, temos Widget de pilha. O widget Stack tem dois tipos de filho, um posicionado que é encapsulado no widget Posicionado e o outro não posicionado, que não é encapsulado no widget Posicionado. Para todos os widgets não posicionados, a propriedade de alinhamento é definida no canto superior esquerdo. Os widgets filhos posicionados são posicionados nas propriedades superior, direita, esquerda e inferior. Os widgets filhos do Stack são impressos de forma que o widget na parte superior se torne o mais na parte inferior da tela e vice-versa. Podemos usar a propriedade key do widget Stack para alterar essa ordem ou atribuir uma ordem diferente.",
    "tipPageView": "O widget PageView permite que o usuário faça a transição entre diferentes telas em seu aplicativo de flutter. Tudo que você precisa para configurá-lo é um PageViewController e um PageView.",
    "tipTable": "O widget de tabela é usado para exibir itens em um layout de tabela. Não há necessidade de usar linhas e colunas para criar uma tabela. Se tivermos várias linhas com a mesma largura das colunas, o widget Tabela é a abordagem certa. SliverList ou Column serão mais adequados se quisermos ter apenas uma coluna. A altura das linhas no widget Tabel depende do conteúdo dentro delas. Mas a largura da coluna pode ser alterada especificando a propriedade columnWidths.",
    "tipDismissible": "Um widget que pode ser descartado arrastando na direção indicada. Arrastar ou arremessar este widget em DismissDirection faz com que o filho deslize para fora de vista. Seguindo a animação do slide, se resizeDuration for não nulo, o widget Dismissible anima sua altura (ou largura, o que for perpendicular à direção de dispensar) para zero sobre resizeDuration.",
    "tipSnackBar": "Uma mensagem leve com uma ação opcional que é exibida rapidamente na parte inferior da tela.",
    "tipGridView": "Flutter GridView é um widget semelhante a um array 2-D em qualquer linguagem de programação. Como o nome sugere, um GridView Widget é usado quando temos que exibir algo em um Grid. Podemos exibir imagens, texto, ícones, etc. no GridView.",
    "tipSliverAppBar": "SliverAppBar é um widget de design de material vibrante que oferece uma barra de aplicativos rolável ou recolhível. A palavra Sliver é fornecida para áreas de rolagem aqui. SliverAppBar basicamente nos dá meios para criar uma barra de aplicativos que pode mudar a aparência, se misturar no fundo ou até mesmo desaparecer conforme rolamos. Já tínhamos o widget AppBar em vibração, o que coloca a barra de aplicativos em uma altura fixa. Mas, olhando ao nosso redor, podemos ver que a interface do usuário da barra de rolagem do aplicativo é amplamente usada. Para atingir a mesma funcionalidade, flutter nos dá o widget SliverAppBar, que normalmente é levado como um widget filho para CustomScrollView (widget de flutter), que fornece a capacidade de interagir com a rolagem.",
    "tipSliverGrid": "Uma tira que coloca vários filhos da caixa em um arranjo bidimensional. SliverGrid coloca seus filhos em posições arbitrárias determinadas por gridDelegate. Cada filho é forçado a ter o tamanho especificado pelo gridDelegate. A direção do eixo principal de uma grade é a direção em que ela rola; a direção do eixo cruzado é a direção ortogonal.",
    "tipNavigator": "Navigator: Como o próprio nome sugere, o Navigator é um widget que nos ajuda a navegar entre as rotas. O navegador segue o método da pilha ao lidar com as rotas. Com base nas ações realizadas pelo usuário, as rotas são empilhadas umas sobre as outras e, quando pressionado de volta, vai para a rota visitada mais recentemente. Navigator é um widget que segue uma disciplina de pilha.",
    "tipDialog": "A caixa de diálogo é um tipo de widget que aparece na janela ou na tela que contém qualquer informação crítica ou pode pedir qualquer decisão. Quando uma caixa de diálogo é exibida, todas as outras funções são desativadas até que você feche a caixa de diálogo ou forneça uma resposta. Usamos uma caixa de diálogo para um tipo diferente de condição, como notificação de alerta, notificação simples em que diferentes opções são mostradas, ou também podemos criar uma caixa de diálogo que pode ser usada como uma guia para mostrar a caixa de diálogo.",
    "tipSendData": "Freqüentemente, você não deseja apenas navegar para uma nova tela, mas também passar dados para a tela. Por exemplo, você pode querer passar informações sobre o item que foi tocado. Lembre-se: as telas são apenas widgets.",
    "tipListView": "No Flutter, ListView é uma lista rolável de widgets organizados linearmente. Ele exibe seus filhos um após o outro na direção de rolagem, ou seja, vertical ou horizontal.",
    "tipPopupMenuButton": "Exibe um menu quando pressionado e chama Selecionado quando o menu é descartado porque um item foi selecionado. O valor passado para onSelected é o valor do item de menu selecionado. Um filho ou ícone pode ser fornecido, mas não ambos. Se o ícone for fornecido, o PopupMenuButton se comportará como um IconButton.",
    "tipRefreshIndicator": "Um widget que suporta o idioma 'deslizar para atualizar' de Material. Quando o descendente Rolável da criança é exibido, um indicador de progresso circular animado é apagado. Quando a rolagem termina, se o indicador foi arrastado longe o suficiente para se tornar completamente opaco, o retorno de chamada onRefresh é chamado. Espera-se que o retorno de chamada atualize o conteúdo do rolável e, em seguida, conclua o Future que ele retorna. O indicador de atualização desaparece após a conclusão do Future do callback.",
    "tipClipRect": "O widget ClipRect é usado para cortar seu filho usando um retângulo. Ele está associado à família Clippers. O principal uso do clippers é cortar qualquer parte do widget conforme necessário. Ele se comporta de forma semelhante ao de ClipRRect e é usado para recortar uma parte do retângulo do widget filho, mas sem os cantos arredondados.",
    "tipClipRRect": "O widget ClipRRect em vibração é usado para prender seu filho usando um retângulo arredondado. Ele está associado à família Clippers. O principal uso do clippers é cortar qualquer parte do widget conforme necessário. Ele se comporta de forma semelhante ao de ClipRect e é usado para cortar uma parte do retângulo do widget filho, mas com cantos arredondados.",
    "tipClipOval": "O widget ClipOval prende o widget filho em forma oval ou circular. Podemos remodelar o widget filho alterando a largura e a altura. Se a largura e a altura forem iguais, a forma será circular. Se a largura e a altura forem diferentes, a forma será oval.",
    "tipClipPath": "Um widget que corta seu filho usando um caminho. Chama um retorno de chamada em um delegado sempre que o widget deve ser pintado. O retorno de chamada retorna um caminho e o widget evita que a criança pinte fora do caminho.",
    "tipFlexible": "Flexível é um widget embutido no flutter que controla como um filho de widgets flex de base que são Row, Column e Flex preencherá o espaço disponível para ele. O widget Expanded em flutter é a abreviação de Flexible com o ajuste padrão de FlexFit.tight. O widget flexível desempenha um papel muito importante na criação de um aplicativo responsivo que tenha a mesma aparência em vários tamanhos de dispositivo. Mas se alguém deseja apenas o preenchimento básico de espaços por widgets, então Expanded também é um bom candidato para isso.",
    "tipExpanded": "Widget expandido em flutter é útil quando queremos que um widget filho ou widgets filhos ocupem todo o espaço disponível ao longo do eixo principal (para Linha, o eixo principal é horizontal e vertical para Coluna). O widget expandido pode ser considerado filho de Linha, Coluna e Flex. E no caso de não querermos dar espaços iguais aos widgets filhos, podemos distribuir o espaço disponível conforme nossa vontade usando fator flexível. O widget expandido é semelhante ao widget Flexível em flutter, com sua propriedade fit definida como FlexFit.tight como padrão. O widget expandido é basicamente uma abreviação de widget flexível. Mas se você está planejando construir aplicativos responsivos ou aplicativos da web, então você definitivamente deve mudar para Flexível para obter mais opções de ajuste.",
    "tipCircleAvatar": "O widget CircleAvatar vem integrado com o flutter SDK. É simplesmente um círculo no qual podemos adicionar a cor de fundo, a imagem de fundo ou apenas algum texto. Geralmente representa um usuário com sua imagem ou com suas iniciais. Embora possamos fazer um widget semelhante do zero, esse widget é útil no desenvolvimento rápido de um aplicativo.",
    "tipFittedBox": "FittedBox é um widget muito útil que dimensiona e posiciona seu filho dentro de si de acordo com o ajuste e o alinhamento. Considere um aplicativo, no qual você precisa obter a entrada do usuário e, em um determinado cenário, o usuário insere uma grande entrada que transborda e espalha outros widgets. Como muitos dos widgets são dinâmicos, o que significa que eles podem aumentar e diminuir de tamanho, de acordo com o tamanho do widget filho. Portanto, neste caso, a interface do usuário não seria adaptável. Para contornar este problema, podemos usar o widget FittedBox. FittedBox impede que seus widgets filhos aumentem de tamanho além de um determinado limite. Ele os redimensiona de acordo com o tamanho disponível. Por exemplo, se o texto é exibido dentro de um contêiner e o texto deve ser inserido pelo usuário. Se o usuário inserir uma grande sequência de texto, o contêiner aumentará além de seu tamanho alocado. Mas, se embrulharmos com FittedBox, então caberia o texto de acordo com o tamanho disponível. Para cordas grandes, ele encolheria de tamanho e, portanto, caberia no contêiner.",
    "tipVisibility": "Mostrar ou ocultar uma criança. Por padrão, a propriedade visible controla se o filho está incluído na subárvore ou não; quando não está visível, o filho substituto (normalmente uma caixa de tamanho zero) é incluído. Uma variedade de sinalizadores pode ser usada para ajustar exatamente como a criança está escondida. (Alterar os sinalizadores dinamicamente não é recomendado, pois pode fazer com que a subárvore filha seja reconstruída, com qualquer estado na subárvore sendo descartado. Normalmente, apenas o sinalizador visível é alterado dinamicamente.)",
    "tipBoxDecoration": "BoxDecoration é um widget embutido na API flutter. Em um nível básico, descreve como uma caixa deve ser pintada na tela. A forma da caixa não precisa ser apenas um retângulo ou um quadrado, ela também pode circular. Ele vem com uma tonelada de propriedades que podemos adicionar uma imagem dentro, adicionar um raio à borda (se a forma for um retângulo), projetar sombra na caixa, etc.",
    "tipSelectableText": "Uma sequência de texto selecionável com um único estilo. O widget SelectableText exibe uma string de texto com um único estilo. A sequência pode quebrar em várias linhas ou pode ser exibida na mesma linha, dependendo das restrições de layout.",
    "tipInteractiveViewer": "Um widget que permite interações de panorâmica e zoom com seu filho.",
    "tipSlider": "Um controle deslizante do Material Design. Usado para selecionar a partir de uma gama de valores.",
    "tipChip": "Um chip de design de material. Chips são elementos compactos que representam um atributo, texto, entidade ou ação. Fornecer um retorno de chamada onDeleted não nulo fará com que o chip inclua um botão para excluir o chip.",
    "tipAspectRatio": "Um widget que tenta dimensionar a criança para uma proporção de aspecto específica. O widget tenta primeiro a maior largura permitida pelas restrições de layout. A altura do widget é determinada pela aplicação da proporção de aspecto dada à largura, expressa como uma proporção da largura para a altura.",
    "tipPlaceholder": "Um widget que desenha uma caixa que representa onde outros widgets um dia serão adicionados. Este widget é útil durante o desenvolvimento para indicar que a interface ainda não está completa.",
    "tipSpacer": "O espaçador cria um espaçador vazio e ajustável que pode ser usado para ajustar o espaçamento entre os widgets em um contêiner Flex, como Linha ou Coluna. O widget Spacer ocupará qualquer espaço disponível, portanto, definir Flex.mainAxisAlignment em um flex container que contém um Spacer para MainAxisAlignment.spaceAround, MainAxisAlignment.spaceBetween ou MainAxisAlignment.spaceEvenly não terá nenhum efeito visível: o Spacer ocupou todos do espaço adicional, portanto, não há nenhum para redistribuir.",
    "tipListWheelScrollView": "ListWheelScrollView é um widget oscilante usado para construir ListView com efeito 3D. Também podemos usar ListView para criar uma lista de itens, mas não podemos adicionar um efeito 3D a ela e também vem com uma restrição de que todos os filhos dentro deste widget devem ter o mesmo tamanho ao longo do eixo de deslocamento. ListWheelScrollView do Flutter adiciona seus filhos em uma roda de rolagem. Isso resulta em um efeito 3D como se as crianças estivessem girando em uma roda. Este widget vem com muitas propriedades. Alguns nos permitem definir o diâmetro da roda, fazer o deslocamento ou mesmo adicionar um efeito de ampliação.",
    "tipImageLoadingBuilder": "Um construtor que especifica o widget a ser exibido ao usuário enquanto uma imagem ainda está sendo carregada. Se for nulo e a imagem for carregada de forma incremental (por exemplo, em uma rede), o usuário não receberá nenhuma indicação do progresso conforme os bytes da imagem são carregados.",
    "tipMouseRegion": "Um widget que rastreia o movimento dos ratos. MouseRegion é usado quando é necessário comparar a lista de objetos sobre os quais o ponteiro do mouse está passando entre este quadro e o último quadro. Isso significa inserir eventos, sair de eventos e cursores do mouse.",
    "tipOpacity": "O widget Opacity que torna seu filho parcialmente transparente. Esta classe colore seu filho em um buffer intermediário e então mescla o filho de volta na cena parcialmente transparente. Para valores de opacidade diferentes de 0,0 e 1,0, esta classe é relativamente cara, pois precisa colorir a criança em um buffer intermediário. Para o valor 0,0, a criança simplesmente não tem cor. Para o valor 1.0, o filho é colorido sem um buffer intermediário.",
    "tipConstrainedBox": "Um widget que impõe restrições adicionais a seu filho. Por exemplo, se você quiser que o filho tenha uma altura mínima de 50.0 pixels lógicos, poderá usar const BoxConstraints (minHeight: 50.0) como as restrições.",
    "tipAlign": "Align Widget é o widget que é usado para alinhar seu filho dentro de si mesmo e, opcionalmente, se dimensiona com base no tamanho do filho. Align Widget é bastante flexível e pode mudar seu tamanho de acordo com o tamanho de seu filho.",
    "tipLayoutBuilder": "Constrói uma árvore de widget que pode depender do tamanho do widget pai. Semelhante ao widget do Construtor, exceto que a estrutura chama a função do construtor no momento do layout e fornece as restrições do widget pai. Isso é útil quando o pai restringe o tamanho da criança e não depende do tamanho intrínseco da criança. O tamanho final do LayoutBuilder corresponderá ao tamanho de seu filho.",
    "tipPadding": "O widget de preenchimento em vibração faz exatamente o que seu nome diz, adiciona preenchimento ou espaço vazio ao redor de um widget ou um monte de widgets. Podemos aplicar preenchimento ao redor de qualquer widget, colocando-o como filho do widget Preenchimento. O tamanho do widget filho dentro do preenchimento é limitado pela quantidade de espaço restante após a adição de um espaço vazio ao redor. O widget Padding adiciona espaço vazio ao redor de qualquer widget usando a classe abstrata EdgeInsetsGeometry.",
    "tipAbsorbPointer": "AbsorbPointer é um widget embutido em flutter que absorve o ponteiro, em outras palavras, evita que sua subárvore seja clicada, tocada, rolada, arrastada e respondida ao passar o mouse. No flutter, a maioria dos widgets já vem com uma opção para desativá-los, por exemplo, em um RaisedButton, podemos definir a função onClicked como null para desativar, ou podemos usar NeverScrollableScrollPhysics () para desativar um ListView. Mas se quisermos desabilitar uma árvore inteira de widgets ou até mesmo uma tela inteira de uma vez, podemos fazer isso com a ajuda do widget AbsorbPointer. IgnorePointer também é um widget semelhante em flutter, que também evita que seus filhos sejam clicados.",
    "tipIgnorePointer": "IgnorePointer é um widget embutido no flutter que é semelhante ao widget AbsorbPointer, ambos evitam que o widget de seus filhos faça eventos de ponteiro que estão gravando, clicando, arrastando, rolando e pairando. Ambos fazem a mesma coisa de duas maneiras diferentes, o widget AbsorbPointer absorve todos os eventos de ponteiro, o que significa que os eventos de ponteiro são encerrados completamente e não podem ser passados em nenhum outro lugar. Por outro lado, o widget IgnorePointer apenas ignora os eventos de ponteiro sem encerrá-lo, o que significa que se houver qualquer outro elemento abaixo da árvore do widget IgnorePointer, ele poderá experimentar esse evento de ponteiro.",
    "tipTooltip": "A dica de ferramenta é um widget embutido no flutter baseado no material design, que exibe uma descrição textual do widget em um rótulo flutuante quando um usuário pressiona longamente e ou passa o mouse sobre o widget. O widget de dica de ferramenta se torna muito útil quando a IU do aplicativo é muito densa para exibir todas as informações de uma vez na tela, de forma que simplesmente torna o aplicativo mais acessível. Existem duas maneiras de implementar a dica de ferramenta em um widget, a primeira é usando o próprio widget e a outra forma é limitada a alguns widgets, como IconButton, FloatingActionButton, etc, que fornecem a dica de ferramenta como uma propriedade que, por sua vez, leva em uma string como um parâmetro. Deve-se lembrar que o widget Tooltip é personalizável por meio de suas propriedades, mas a propriedade tooltip não é.",
    "tipFlutterLogo": "O widget FlutterLogo é tão simples quanto parece, é apenas o logotipo oscilante na forma de um ícone. Este widget também vem embutido com flutter SDK. Este widget pode ser usado como um espaço reservado para uma imagem ou ícone.",
    "tipSizedBox": "SizedBox é um widget embutido no Flutter SDK. É uma caixa simples com um tamanho especificado. Ele pode ser usado para definir restrições de tamanho para o widget filho, colocar um SizedBox vazio entre os dois widgets para obter algum espaço entre eles ou algo mais. É um pouco semelhante a um widget de contêiner com menos propriedades.",
    "tipFloatingActionButton": "Um botão de ação flutuante é um botão de ícone circular que passa sobre o conteúdo para promover uma ação principal no aplicativo. Os botões de ação flutuantes são mais comumente usados no campo Scaffold.floatingActionButton.",
    "tipCheckbox": "Checkbox in flutter é um widget de design de material. É sempre usado no Stateful Widget, pois não mantém um estado próprio. Podemos usar sua propriedade onChanged para interagir ou modificar outros widgets no aplicativo flutter. Como a maioria dos outros widgets de flutter, ele também vem com muitas propriedades como activeColor, checkColor, mouseCursor, etc, para permitir que os desenvolvedores tenham controle total sobre a aparência do widget.",
    "tipEndDrawer": "O EndDrawer é o painel exibido ao lado do corpo (widget Scaffold). Geralmente está oculto em dispositivos móveis. Podemos abri-lo deslizando da direita para a esquerda ou personalizá-lo para abrir ao pressionar um ícone ou botão. Este widget é semelhante ao widget Drawer já presente em vibração, exceto pelo fato de o Drawer por padrão abrir da esquerda para a direita e o endDrawer por padrão abrir da direita para a esquerda. No entanto, essa direção pode ser alterada usando a propriedade textDirection.",
    "tipBanner": "O widget Banner vem integrado com API de vibração. É um pouco semelhante ao banner de depuração que estamos acostumados a ver no canto superior direito de um aplicativo flutter no modo de depuração. Ele nos permite mostrar uma mensagem ou texto em cima de qualquer outro widget.",
    "tipBorderRadius": "BorderRadius é um widget embutido no flutter. Sua principal funcionalidade é adicionar uma curva ao redor do canto da borda de um widget. Existem no total cinco maneiras de usar este widget, a primeira é usando BorderRadius.all, o raio de todos os cantos é o mesmo aqui. A segunda maneira é usando BorderRadius.Circle, aqui precisamos especificar o raio apenas uma vez, o que seria um valor duplo. A terceira maneira é usando BorderRadius.horizontal, aqui podemos especificar diferentes raios de borda para o lado esquerdo e o lado direito. A quarta maneira é usando BorderRadius. Apenas, pode ter um raio diferente para todos os quatro cantos da borda. E a última maneira é usando BorderRadius.vertical, que pode dar um raio diferente para a parte superior e a parte inferior da borda.",
    "tipSingleChildScrollView": "Uma caixa na qual um único widget pode ser rolado. Este widget é útil quando você tem uma única caixa que normalmente estará totalmente visível, por exemplo, um mostrador de relógio em um seletor de hora, mas você precisa se certificar de que pode ser rolado se o contêiner ficar muito pequeno em um eixo (a direção de rolagem )",
    "tipBoxShadow": "BoxShadow é um widget embutido no flutter, cuja funcionalidade é projetar sombra em uma caixa. O widget BoxShadow é geralmente usado com BoxDecoration. No widget BoxDecoration, um de seus parâmetros é boxShadow que pega uma lista de BoxShadow para projetar uma sombra ao redor de uma caixa.",
    "tipBottomNavigationBar": "O widget BottonNavigationBar é usado para mostrar a parte inferior de um aplicativo. Pode consistir em vários itens, como ícones, texto ou ambos, que levam a uma rota diferente, dependendo do design do aplicativo. Destina-se a ajudar o usuário a navegar para diferentes seções do aplicativo em geral.",
    "tipExpansionPanel": "Quando queremos expandir e recolher coisas, podemos fazer isso com a ajuda de um painel de expansão. Esta lista do painel de expansão é usada principalmente nos aplicativos e fornece recursos extras para o aplicativo. Podemos criar uma lista de filhos e envolvê-la com uma Lista do Painel de Expansão. Também podemos criar mais de um painel de expansão em nosso aplicativo. Podemos controlar se o painel está aberto ou não pela propriedade isExpanded.",
    "tipPaint": "Uma descrição do estilo a ser usado ao desenhar em uma tela. A maioria das APIs no Canvas usa um objeto Paint para descrever o estilo a ser usado para essa operação.",
    "tipClipboard": "Métodos utilitários para interagir com a área de transferência do sistema.",
    "tipPageRouteBuilder": "As rotas são simplesmente páginas em aplicativos Flutter. Freqüentemente, um aplicativo precisa passar de uma página para outra. Mas para tornar essas transições mais suaves, animações podem ser usadas. Essas animações podem ser usadas para curvar ou interpolar o objeto Animation da classe PageRouteBuilder para alterar a animação da transição.",
    "tipShaderMask": "Um widget que aplica uma máscara gerada por um Shader a seu filho.",
    "tipAnimatedContainer": "No Flutter, um contêiner é um widget simples com propriedades bem definidas, como altura, largura e cor, etc. O widget AnimatedContainer é um widget de contêiner simples com animações. Esses tipos de widgets podem ser animados alterando os valores de suas propriedades, que são iguais aos do widget Container. Esses tipos de animação no Flutter são conhecidos como ‘Animação implícita. Discutiremos então em detalhes neste artigo, criando um aplicativo simples com o widget AnimatedContainer.",
    "tipAnimatedCrossFade": "Um widget que se esmaece entre dois filhos dados e se anima entre seus tamanhos.",
    "tipAnimatedOpacity": "Versão animada de Opacity que faz a transição automática da opacidade da criança ao longo de um determinado período, sempre que a opacidade fornecida muda.",
    "tipAnimatedDefaultTextStyle": "Versão animada de DefaultTextStyle que faz a transição automática do estilo de texto padrão (o estilo de texto a ser aplicado a widgets de Texto descendentes sem estilo explícito) ao longo de uma determinada duração sempre que o estilo for alterado.",
    "tipCustomPaint": "A interface usada por CustomPaint (na biblioteca de widgets) e RenderCustomPaint (na biblioteca de renderização). Para implementar um pintor customizado, crie uma subclasse ou implemente esta interface para definir seu delegado de pintura customizado. As subclasses de CustomPaint devem implementar os métodos paint e shouldRepaint e, opcionalmente, também podem implementar os métodos hitTest e shouldRebuildSemantics e o getter semanticsBuilder.",
    "tipTransform": "Um widget que aplica uma transformação antes de pintar seu filho. Ao contrário de RotatedBox, que aplica uma rotação antes do layout, este objeto aplica sua transformação logo antes da pintura, o que significa que a transformação não é levada em consideração ao calcular quanto espaço o filho deste widget (e, portanto, este widget) consome.",
    "tipDraggableScrollableSheet": "Um contêiner para um rolável que responde a gestos de arrastar redimensionando o rolável até que um limite seja atingido e, em seguida, rolando.",
    "tipIndexedStack": "Uma pilha que mostra um único filho de uma lista de filhos. O filho exibido é aquele com o índice fornecido. A pilha é sempre tão grande quanto o filho maior.",
    "tipColorFiltered": "Aplica um ColorFilter a seu filho. Este widget aplica uma função independente a cada pixel do conteúdo infantil, de acordo com o ColorFilter especificado. Use o construtor ColorFilter.mode para aplicar um Color usando um BlendMode. Em vez disso, use o widget BackdropFilter, se o ColorFilter precisar ser aplicado ao conteúdo abaixo do filho.",
    "tipDataTable": "O widget DataTable permite que você crie uma tabela que dimensiona automaticamente suas colunas de acordo com o que realmente está nas células.",
    "tipFadeInImage": "Uma imagem que mostra uma imagem de espaço reservado enquanto a imagem de destino está sendo carregada e desaparece na nova imagem quando ela é carregada. Use esta classe para exibir imagens de carregamento longo, como o novo NetworkImage, para que a imagem apareça na tela com uma animação elegante, em vez de aparecer abruptamente na tela.",
    "tipFadeTransition": "Anima a opacidade de um widget.",
    "tipImageFiltered": "O Flutter fornece um ImageFiltered, uma classe de baixo nível que pega pixels e os reorganiza. Ele aplica um ImageFilter a seu filho. Uma operação de filtro a ser aplicada a uma imagem raster. ImageFiltered irá desfocar as imagens, o texto e qualquer coisa ficará desfocada. Também funciona em qualquer matriz para transformação, como redimensionamento, translação, inclinação, rotação, etc.",
    "tipPositioned": "Um widget que controla onde um filho de uma Pilha está posicionado. Um widget Positioned deve ser descendente de uma Stack, e o caminho do widget Positioned para sua Stack envolvente deve conter apenas StatelessWidgets ou StatefulWidgets (não outros tipos de widgets, como RenderObjectWidgets).",
    "tipLinearProgressIndicator": "Um LinearProgressIndicator, também conhecido como barra de progresso, é um widget que mostra o progresso em uma direção linear ou ao longo de uma linha para indicar que o aplicativo está em andamento.",
    "tipLimitedBox": "Uma caixa que limita seu tamanho apenas quando não está restrita. Se a largura máxima deste widget não for restrita, a largura de seu filho será limitada a maxWidth. Da mesma forma, se a altura máxima deste widget não for restringida, a altura de seu filho será limitada a maxHeight.",
    "tipAnimatedSwitcher": "Um widget que, por padrão, faz um cross-fade entre um novo widget e o widget definido anteriormente no AnimatedSwitcher como um filho.",
    "tipCheckboxListTile": "CheckboxListTile é um widget embutido no flutter. Podemos dizer que é uma combinação de CheckBox com ListTile. Suas propriedades, como value, activeColor e checkColor são semelhantes ao widget CheckBox, e title, subtitle, contentPadding, etc. são semelhantes ao widget ListTile. Podemos tocar em qualquer lugar em CheckBoxListTile para ativar a caixa de seleção.",
    "tipSwitchListTile": "Um ListTile com um switch. Em outras palavras, um switch com um rótulo.",
    "tipExpansionPanelList": "Uma lista do painel de expansão de material que exibe seus filhos e anima as expansões.",
    "tipFractionallySizedBox": "Um widget que dimensiona seu filho para uma fração do espaço total disponível.",
    "tipScrollbar": "As barras de rolagem são interativas e também usarão o PrimaryScrollController se um controlador não estiver definido. Os polegares da barra de rolagem podem ser arrastados ao longo do eixo principal de ScrollView para alterar a ScrollPosition. Tocar ao longo da trilha exclusiva do polegar acionará um ScrollIncrementType.page com base na posição relativa ao polegar.",
    "tipOverflowBox": "Um widget que impõe restrições diferentes em seu filho do que obtém de seu pai, possivelmente permitindo que o filho transborde o pai.",
    "tipRadioListTile": "Um ListTile com um rádio. Em outras palavras, um botão de opção com um rótulo. Todo o bloco da lista é interativo: tocar em qualquer lugar do bloco seleciona o botão de rádio.",
    "tipTextField": "TextField e TextFormField são os dois widgets mais comuns para obter a entrada do usuário. Eles podem ser usados na criação de formulários, páginas de login, etc.",
    "tipScrollController": "Controla um widget de rolagem. Os controladores de rolagem são normalmente armazenados como variáveis de membro em objetos de estado e são reutilizados em cada State.build. Um único controlador de rolagem pode ser usado para controlar vários widgets roláveis, mas algumas operações, como ler o deslocamento de rolagem, exigem que o controlador seja usado com um único widget rolável.",
    "tipSplashScreen": "Uma tela inicial é um elemento de controle gráfico que consiste em uma janela contendo uma imagem, um logotipo e a versão atual do software. Uma tela inicial pode aparecer enquanto um jogo ou programa está sendo iniciado. Uma página inicial é uma página de introdução em um site.",
    "tipPushNamed": "Envia uma rota nomeada para o navegador que envolve mais fortemente o contexto fornecido. O nome da rota será passado para o retorno de chamada Navigator.onGenerateRoute. A rota retornada será inserida no navegador.",
    "tipOnGenerateRoute": "O retorno de chamada do gerador de rota usado quando o aplicativo é navegado para uma rota nomeada. Se isso retornar nulo ao construir as rotas para lidar com o initialRoute especificado, todas as rotas serão descartadas e Navigator.defaultRouteName será usado em seu lugar (/). Veja initialRoute. Durante a operação normal do aplicativo, o retorno de chamada onGenerateRoute só será aplicado aos nomes de rota enviados pelo aplicativo e, portanto, nunca deve retornar nulo.",
    "tipWillPopScope": "Registra um retorno de chamada para vetar as tentativas do usuário de dispensar o ModalRoute anexo.",
    "tipTextOverflow": "Se você tiver um texto longo que não cabe em uma linha, uma das soluções é truncar o texto. Flutter fornece alguns modos para truncar texto transbordado. Ele tem um enum chamado TextOverflow, cujos valores possíveis são: .clip, .fade, .ellipsis, .visible",
    "tipStepper": "Um widget de passo de material que exibe o progresso por meio de uma sequência de etapas. Os steppers são particularmente úteis no caso de formulários em que uma etapa exige a conclusão de outra ou em que várias etapas precisam ser concluídas para o envio de todo o formulário. O widget é um invólucro flexível. Uma classe pai deve passar currentStep para este widget com base em alguma lógica acionada pelos três callbacks que ele fornece.",
    "tipToggleButtons": "Um conjunto de botões de alternância. A lista de crianças é apresentada ao longo da direção. O estado de cada botão é controlado por isSelected, que é uma lista de bools que determinam se um botão está em um estado não selecionado ou selecionado. Ambos são correlacionados por seu índice na lista. O comprimento de isSelected deve corresponder ao comprimento da lista de filhos.",
    "tipDatePicker": "DatePicker é um widget de material em flutter que aparece em uma caixa de diálogo contendo um selecionador de data do Material Design chamando a função embutida de flutter. Para criar um DatePicker no Flutter, usamos showDatePicker (), que é uma função assíncrona. Quando chamamos a função, ela exibe a caixa de diálogo e espera que o usuário selecione a data. Ele retorna a data selecionada pelo usuário e a exibe em um widget de texto quando o usuário confirma a caixa de diálogo. Se o usuário cancelar o diálogo, ele retornará nulo.",
    "tipExpansionTile": "Um ListTile de linha única com um botão à direita que expande ou recolhe o bloco para revelar ou ocultar os filhos. Este widget é normalmente usado com ListView para criar uma entrada de lista expandir / recolher. Quando usado com widgets de rolagem como ListView, um PageStorageKey exclusivo deve ser especificado para permitir que o ExpansionTile salve e restaure seu estado expandido quando ele é rolado para dentro e fora da visualização.",
    "tipLinearGradient": "Um gradiente linear 2D. Esta classe é usada por BoxDecoration para representar gradientes lineares. Isso abstrai os argumentos para o novo construtor ui.Gradient.linear da biblioteca dart: ui. Um gradiente possui dois pontos de ancoragem, início e fim. O ponto inicial corresponde a 0,0 e o ponto final corresponde a 1,0. Esses pontos são expressos em frações, de forma que o mesmo gradiente pode ser reutilizado com caixas de tamanhos variados sem alterar os parâmetros. (Isso contrasta com o novo ui.Gradient.linear, cujos argumentos são expressos em pixels lógicos.) As cores são descritas por uma lista de objetos Color. Deve haver pelo menos duas cores. A lista de paradas, se especificada, deve ter o mesmo comprimento das cores. Ele especifica frações do vetor do início ao fim, entre 0,0 e 1,0, para cada cor. Se for nulo, uma distribuição uniforme é assumida.",
    "tipDeviceOrientation": "Especifica uma orientação de dispositivo particular. Para determinar quais valores correspondem a quais orientações, primeiro posicione o dispositivo em sua orientação padrão (esta é a orientação que o sistema primeiro usa para seu logotipo de inicialização, ou a orientação em que os logotipos de hardware ou marcações estão na vertical, ou a orientação em que as câmeras estão no topo). Se esta for uma orientação retrato, então esta é a orientação retratoUp. Caso contrário, é landscapeLeft. Conforme você gira o dispositivo 90 graus no sentido anti-horário em torno do eixo que perfura a tela, você avança através de cada valor neste enum na ordem fornecida.",
    "tipSystemUIOverlayStyle": "Especifica uma preferência para o estilo das sobreposições do sistema.",
    "tipBaseline": "Um widget que posiciona seu filho de acordo com a linha de base do filho. Este widget desloca o filho para baixo de forma que a linha de base do filho (ou a parte inferior do filho, se o filho não tiver linha de base) é pixels lógicos de linha de base abaixo do topo desta caixa, então dimensiona esta caixa para conter o filho. Se a linha de base for menor que a distância do topo do filho até a linha de base do filho, então o filho será alinhado pelo topo.",
    "tipActionChip": "Um chip de ação do material design. Fichas de ação são um conjunto de opções que acionam uma ação relacionada ao conteúdo primário. Os chips de ação devem aparecer dinamicamente e contextualmente em uma IU. Os chips de ação podem ser usados para desencadear uma ação ou mostrar o progresso e a confirmação. Eles não podem ser desativados; se a ação não for aplicável, o chip não deve ser incluído na interface. (Isso contrasta com os botões, onde as opções indisponíveis são geralmente representadas como controles desativados.) Os chips de ação são exibidos após o conteúdo principal, como abaixo de um cartão ou persistentemente na parte inferior de uma tela.",
    "tipBackdropFilter": "Um widget que aplica um filtro ao conteúdo pintado existente e, em seguida, pinta filho. O filtro será aplicado a toda a área dentro do clipe do widget pai ou ancestral. Se não houver clipe, o filtro será aplicado em tela inteira.",
    "tipTypedef": "Um typedef, ou apelido de tipo de função, ajuda a definir ponteiros para código executável na memória.",
    "tipExpandIcon": "Um widget que representa um botão giratório de expansão / recolhimento. O ícone gira 180 graus quando pressionado e, em seguida, reverte a animação em um segundo pressionamento. O ícone subjacente é Icons.expand_more. O ícone de expansão não inclui um rótulo semântico para acessibilidade. Para ser acessível, deve ser combinado com um rótulo usando MergeSemantics. Isso é feito automaticamente pelo widget ExpansionPanel.",
    "tipShapeDecoration": "Uma descrição imutável de como pintar uma forma arbitrária. A classe ShapeDecoration fornece uma maneira de desenhar um ShapeBorder, opcionalmente preenchendo-o com uma cor ou gradiente, opcionalmente pintando uma imagem nele e, opcionalmente, projetando uma sombra.",
    "tipAutocomplete": "Um widget para ajudar o usuário a fazer uma seleção inserindo algum texto e escolhendo entre uma lista de opções. A entrada de texto do usuário é recebida em um campo construído com o parâmetro fieldViewBuilder. As opções a serem exibidas são determinadas usando optionsBuilder e renderizadas com optionsViewBuilder.",
    "tipSplit": "Divide a string em correspondências de padrão e retorna uma lista de substrings. Encontra todas as correspondências de padrão nesta string, usando Pattern.allMatches, e retorna a lista das substrings entre as correspondências, antes da primeira correspondência e depois da última correspondência.",
    "tipAnimatedList": "Um contêiner de rolagem que anima os itens quando eles são inseridos ou removidos. O AnimatedListState deste widget pode ser usado para inserir ou remover itens dinamicamente. Para referir-se ao AnimatedListState, forneça uma GlobalKey ou use o método estático de do retorno de chamada de entrada de um item.",
    "tipChoiceChip": "Um chip de escolha de material design. ChoiceChips representam uma única escolha de um conjunto. As fichas de escolha contêm texto descritivo ou categorias relacionadas. Requer que um de seus ancestrais seja um widget de Material. Os argumentos selecionados e de rótulo não devem ser nulos.",
    "tipSlideTransition": "Anima a posição de um widget em relação à sua posição normal. A tradução é expressa como um deslocamento dimensionado para o tamanho da criança. Por exemplo, um deslocamento com dx de 0,25 resultará em uma translação horizontal de um quarto da largura do filho. Por padrão, os deslocamentos são aplicados no sistema de coordenadas da tela (portanto, deslocamentos x positivos movem o filho para a direita). Se um textDirection for fornecido, os deslocamentos serão aplicados na direção de leitura, portanto, no texto da direita para a esquerda, os deslocamentos x positivos se movem para a esquerda e, no texto da esquerda para a direita, os deslocamentos x positivos se movem para a direita.",
    "tipJoin": "Converte cada elemento em uma String e concatena as strings. Faz a iteração por meio de elementos desse iterável, converte cada um em uma String chamando Object.toString e, em seguida, concatena as strings, com a string separadora intercalada entre os elementos.",
    "tipDecorationImage": "Uma imagem para uma decoração de caixa. A imagem é pintada com paintImage, que descreve os significados dos vários campos nesta classe com mais detalhes.",
    "tipNavigationRail": "Um widget de material que deve ser exibido à esquerda ou à direita de um aplicativo para navegar entre um pequeno número de visualizações, normalmente entre três e cinco. O trilho de navegação destina-se a layouts com janelas de exibição amplas, como um desktop web ou layout de paisagem de tablet. Para layouts menores, como retrato móvel, um BottomNavigationBar deve ser usado. Um trilho de navegação geralmente é usado como o primeiro ou último elemento de uma Linha que define o corpo do Scaffold do aplicativo. A aparência de todos os NavigationRails em um aplicativo pode ser especificada com NavigationRailTheme. Os valores padrão para propriedades de tema nulas são baseados em ThemeData.textTheme, ThemeData.iconTheme e ThemeData.colorScheme do Tema.",
    "tipAnimatedSize": "Widget animado que faz a transição automática de tamanho ao longo de uma determinada duração, sempre que o tamanho da criança muda.",
    "tipFlow": "Um widget que dimensiona e posiciona os filhos de forma eficiente, de acordo com a lógica de um FlowDelegate. Os layouts de fluxo são otimizados para reposicionar filhos usando matrizes de transformação. O contêiner de fluxo é dimensionado independentemente dos filhos pela função FlowDelegate.getSize do delegado. Os filhos são então dimensionados independentemente de acordo com as restrições da função FlowDelegate.getConstraintsForChild.",
    "tipUnconstrainedBox": "Um widget que não impõe restrições a seu filho, permitindo que ele seja renderizado em seu tamanho natural. Isso permite que um filho renderize no tamanho que renderia se estivesse sozinho em uma tela infinita, sem restrições. Esse contêiner tentará então adotar o mesmo tamanho, dentro dos limites de suas próprias restrições. Se terminar com um tamanho diferente, ele alinhará o filho com base no alinhamento. Se a caixa não puder se expandir o suficiente para acomodar o filho inteiro, o filho será cortado.",
    "tipIntrinsicWidth": "Um widget que dimensiona seu filho para a largura intrínseca máxima da criança. Esta classe é útil, por exemplo, quando a largura ilimitada está disponível e você deseja um filho que, de outra forma, tentaria se expandir infinitamente para, em vez disso, se dimensionar para uma largura mais razoável. As restrições que este widget passa para seu filho irão aderir às restrições do pai, portanto, se as restrições não forem grandes o suficiente para satisfazer a largura intrínseca máxima do filho, o filho terá menos largura do que de outra forma. Da mesma forma, se a restrição de largura mínima for maior do que a largura intrínseca máxima da criança, a criança receberá mais largura do que receberia de outra forma.",
    "tipBorderSide": "Um lado da borda de uma caixa. Um Border consiste em quatro objetos BorderSide: Border.top, Border.left, Border.right e Border.bottom.",
    "tipHapticFeedback": "Permite acesso à interface de feedback tátil no dispositivo. Essa API é intencionalmente concisa, pois chama o comportamento padrão da plataforma. Não é adequado para o controle preciso do módulo de feedback tátil do sistema.",
    "tipSwitch": "Uma chave de design de material. Usado para alternar o estado ligado / desligado de uma única configuração. O switch em si não mantém nenhum estado. Em vez disso, quando o estado da chave muda, o widget chama o retorno de chamada onChanged. A maioria dos widgets que usam um switch ouvirá o retorno de chamada onChanged e reconstruirá o switch com um novo valor para atualizar a aparência visual do switch.",
    "tipCustomSingleChildLayout": "Um widget que transfere o layout de seu único filho para um delegado. O delegado pode determinar as restrições de layout para o filho e pode decidir onde posicionar o filho. O delegado também pode determinar o tamanho do pai, mas o tamanho do pai não pode depender do tamanho do filho.",
    "tipFilterChip": "Um chip de filtro de material design. Os chips de filtro usam tags ou palavras descritivas como forma de filtrar o conteúdo. Os chips de filtro são uma boa alternativa aos widgets Checkbox ou Switch. Ao contrário dessas alternativas, os chips de filtro permitem opções claramente delineadas e expostas em uma área compacta.",
    "tipInputChip": "Um chip de entrada de material design. Os chips de entrada representam uma informação complexa, como uma entidade (pessoa, lugar ou coisa) ou texto de conversação, em uma forma compacta. Os chips de entrada podem ser selecionados definindo onSelected, deletable definindo onDeleted e pressionáveis como um botão com onPressed. Eles têm um rótulo e podem ter um ícone à esquerda (veja avatar) e um ícone à direita (deleteIcon). As cores e o preenchimento podem ser personalizados.",
    "tipAnimatedPadding": "Versão animada do Padding que faz a transição automática do recuo ao longo de uma determinada duração, sempre que a inserção for alterada.",
    "tipAnimatedModalBarrier": "Um widget que evita que o usuário interaja com os widgets atrás dele e pode ser configurado com um valor de cor animado. A barreira modal é a tela que é renderizada atrás de cada rota, o que geralmente evita que o usuário interaja com a rota abaixo da rota atual e, normalmente, obscurece parcialmente essas rotas. Por exemplo, quando uma caixa de diálogo está na tela, a página abaixo da caixa de diálogo geralmente é escurecida pela barreira modal.",
    "tipAppBar": "Uma barra de aplicativos de material design. Uma barra de aplicativos consiste em uma barra de ferramentas e potencialmente outros widgets, como TabBar e FlexibleSpaceBar. Barras de aplicativos normalmente expõem uma ou mais ações comuns com IconButtons que são opcionalmente seguidos por um PopupMenuButton para operações menos comuns (às vezes chamado de menu flutuante). Barras de aplicativos são normalmente usadas na propriedade Scaffold.appBar, que coloca a barra de aplicativos como um widget de altura fixa na parte superior da tela.",
    "tipOverlayEntry": "Um local em uma sobreposição que pode conter um widget. As entradas de sobreposição são inseridas em uma sobreposição usando as funções OverlayState.insert ou OverlayState.insertAll. Para encontrar a sobreposição envolvente mais próxima para um determinado BuildContext, use a função Overlay.of. Uma entrada de sobreposição pode estar em no máximo uma sobreposição de cada vez. Para remover uma entrada de sua sobreposição, chame a função remover na entrada de sobreposição. Como uma Overlay usa um layout Stack, as entradas de overlay podem usar Positioned e AnimatedPositioned para se posicionar dentro da overlay.",
    "tipMaterialBanner": "Um banner do Material Design. Um banner exibe uma mensagem importante e sucinta e fornece ações para os usuários endereçarem (ou dispensar o banner). É necessária uma ação do usuário para que seja dispensado. Os banners devem ser exibidos na parte superior da tela, abaixo da barra superior do aplicativo. Eles são persistentes e não modais, permitindo que o usuário os ignore ou interaja com eles a qualquer momento."
}